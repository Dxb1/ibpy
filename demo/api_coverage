#!/usr/bin/env python
# -*- coding: utf-8 -*-

##
# This script attempts to determine how much of the TWS API is
# available from IbPy.
#
# It's not meant as an example of correct use of the package, nor is
# it an example of correct use of a programming language.
##

from pprint import pprint
from time import sleep, strftime

from ib.ext.Contract import Contract
from ib.ext.ExecutionFilter import ExecutionFilter
from ib.ext.Order import Order
from ib.ext.ScannerSubscription import ScannerSubscription
from ib.opt import ibConnection, message


seen_messages = dict.fromkeys(message.registry.values(), 0)
unknown_messages = {}
seen_methods = {}


def qqqq_id():
    return 0


def qqqq_contract():
    qqqq = Contract()
    qqqq.m_symbol = 'QQQQ'
    qqqq.m_secType = 'STK'
    qqqq.m_exchange = 'SMART'
    return qqqq


order_ids = [0]


def qqqq_order_id():
    return order_ids[-1]


def qqqq_order(limit_price=None):
    order = Order()
    order.m_minQty = 100
    if limit_price is not None:
        order.m_lmtPrice = limit_price
        order.m_orderType = 'MKT'
        order.m_totalQuantity = 100
        order.m_action = 'BUY'
    return order


def exec_filter():
    contract = qqqq_contract()
    filt = ExecutionFilter()
    filt.m_clientId = 0
    filt.m_symbol = contract.m_symbol
    filt.m_secType = contract.m_secType
    filt.m_exchange = contract.m_exchange
    return filt


ignore_errors = [2104, 2106, ]


def watcher(msg):
    cls = msg.__class__
    try:
        seen_messages[cls] += 1
    except (KeyError, ):
        unknown_messages[cls] = 1 + unknown_messages.setdefault(cls, 0)
    if cls.__name__ == 'Error':
        args = msg.errorCode, msg.errorMsg
        if msg.errorCode not in ignore_errors:
            print 'Error:  code=%-4s message=%s' % args


def run_0(connection):
    connection.setServerLogLevel(5)
    connection.reqCurrentTime()
    connection.reqAccountUpdates(1, '')
    ##connection.reqManagedAccts()
    ##connection.requestFA(connection.GROUPS)
    ##connection.replaceFA(connection.GROUPS, '')
    def track_order_ids(msg):
        order_ids.append(msg.orderId)
    connection.register(track_order_ids, 'NextValidId')
    connection.reqIds(10)


def run_1(connection):
    subscript = ScannerSubscription()
    subscript.numberOfRows(3)
    subscript.locationCode('STK.NASDAQ')
    connection.reqScannerSubscription(qqqq_id(), subscript)
    connection.reqScannerParameters()
    sleep(1)
    connection.cancelScannerSubscription(qqqq_id())


tick_msgs = []


def run_2(connection):
    def cb(msg):
        tick_msgs.append(msg)
    connection.register(cb, 'TickSize', 'TickPrice')
    connection.reqMktData(qqqq_id(),
                          qqqq_contract(),
                          '100,101,104,106,162,165,221,225,236',
                          False)
    sleep(1)
    connection.cancelMktData(qqqq_id())


def run_3(connection):
    contract = qqqq_contract()
    connection.reqMktDepth(qqqq_id(), qqqq_contract(), 10)
    sleep(1)
    connection.cancelMktDepth(qqqq_id())


def run_4(connection):
    connection.reqAllOpenOrders()
    connection.reqAutoOpenOrders(True)
    connection.reqOpenOrders()
    connection.reqExecutions(exec_filter())


def run_5(connection):
    connection.reqNewsBulletins(True)
    sleep(1)
    connection.cancelNewsBulletins()


def run_6(connection):
    try:
        askprice = [m.price for m in tick_msgs
                    if getattr(m, 'price', None) and m.field==2][0]
    except (IndexError, ):
        askprice = 100.0
    order = qqqq_order(askprice)
    connection.placeOrder(id=qqqq_order_id(),
                          contract=qqqq_contract(),
                          order=order)
    #connection.exerciseOptions()
    contract = qqqq_contract()
    connection.reqContractDetails(contract)


def run_7(connection):
    endtime = strftime('%Y%m%d %H:%M:%S')
    connection.reqHistoricalData(
            tickerId=qqqq_id(),
            contract=qqqq_contract(),
            endDateTime=endtime,
            durationStr='2 D',
            barSizeSetting='30 mins',
            whatToShow='TRADES',
            useRTH=0,
            formatDate=1)
    sleep(1)
    connection.cancelHistoricalData(qqqq_id())


def ___run_8(connection):
    ## prompt for shutdown?
    def cb(*a, **b):
        print '!!', a, b

    connection.register(cb, 'ExecDetails')
    filtr = exec_filter()
    connection.reqExecutions(filtr)
    snooze = 20
    print 'Waiting %s seconds for %s exec details' % (snooze, filtr.m_symbol)
    sleep(snooze)


def __run_9(connection):
    connection.reqRealTimeBars(qqqq_id(), qqqq_contract(),
                               5, 'TRADES', 0)
    snooze = 1
    sleep(snooze)


def run_last(connection):
    sleep(1)
    connection.eDisconnect()


unseen_hints = {
    'OpenOrder':'only works with existing order(s) before connecting',
    'RealtimeBar':'only works during trading hours',
    'ReceiveFA':'does not work with demo account',
    'UpdateNewsBulletin':'news bulletins may not be available',
    'ConnectionClosed':'may work if TWS is closed during script',
    }


def main():
    con = ibConnection()
    con.registerAll(watcher)
    con.connect()
    sleep(5)

    calls = [v for k, v in globals().items() if k.startswith('run_')]
    for call in sorted(calls):
        call(con)

    type_count = len(seen_messages)
    seen = [(k, v) for k, v in seen_messages.items() if v]
    unseen = [(k, v) for k, v in seen_messages.items() if not v]

    print
    if seen:
        print 'Seen Message Types (count):'
        for cls, count in sorted(seen):
            print '   %s (%s)' % (cls.__name__, count, )
    else:
        print 'Total failure; no messages received.'

    print
    if unseen:
        print 'Unseen Message Types (help):'
        for cls, zero in sorted(unseen):
            name = cls.__name__
            help = unseen_hints.get(name, '')
            print '   %s%s' % (name, ' (%s)' % help if help else '', )
    else:
        print 'All Message types received.'

    print
    print 'Summary:'
    args = (type_count, len(seen), len(unseen),
            100*len(seen)/float(type_count))
    print '   total:%s  seen:%s  unseen:%s  coverage:%2.2f%%' % args

if __name__ == '__main__':
    main()

