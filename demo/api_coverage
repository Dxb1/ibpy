#!/usr/bin/env python
# -*- coding: utf-8 -*-

##
# This script attempts to determine how much of the TWS API is
# available from IbPy.
#
# It's not meant as an example of correct use of the package, nor is
# it an example of correct use of a programming language.
##

from functools import partial
from time import sleep, strftime

from ib.ext.ComboLeg import ComboLeg
from ib.ext.Contract import Contract
from ib.ext.ExecutionFilter import ExecutionFilter
from ib.ext.Order import Order
from ib.ext.ScannerSubscription import ScannerSubscription
from ib.opt import ibConnection, message


rec_msgs = {}
unrec_msgs = {}
order_ids = [0]
host, port, client_id = 'localhost', 7496, 0


def qqqq_id():
    return 0


def qqqq_contract():
    qqqq = Contract()
    qqqq.m_symbol = 'QQQQ'
    qqqq.m_secType = 'STK'
    qqqq.m_exchange = 'SMART'
    return qqqq


def qqqq_order_id():
    return order_ids[-1]


def qqqq_order(limit_price=None):
    order = Order()
    order.m_minQty = 100
    if limit_price is not None:
        order.m_lmtPrice = limit_price
        order.m_orderType = 'MKT'
        order.m_totalQuantity = 100
        order.m_action = 'BUY'
    return order


def exec_filter():
    contract = qqqq_contract()
    filt = ExecutionFilter()
    filt.m_clientId = client_id
    filt.m_symbol = contract.m_symbol
    filt.m_secType = contract.m_secType
    filt.m_exchange = contract.m_exchange
    return filt


def watcher():
    rec_msgs.update(dict([(c, []) for c in message.registry.values()]))
    def inner(msg):
        cls = msg.__class__
        try:
            rec_msgs[cls].append(msg)
        except (KeyError, ):
            unrec_msgs.setdefault(cls, []).append(msg)
    return inner


def run_0(connection):
    connection.setServerLogLevel(5)
    connection.reqCurrentTime()
    connection.reqAccountUpdates(1, 'DF16165')
    connection.reqManagedAccts()
    connection.requestFA(connection.GROUPS)
    connection.replaceFA(connection.GROUPS, '')
    def track_order_ids(msg):
        order_ids.append(msg.orderId)
    connection.register(track_order_ids, 'NextValidId')
    connection.reqIds(10)


short_sleep = partial(sleep, 1)


def run_1(connection):
    subscript = ScannerSubscription()
    subscript.numberOfRows(3)
    subscript.locationCode('STK.NYSE')
    connection.reqScannerSubscription(qqqq_id(), subscript)
    connection.reqScannerParameters()
    short_sleep()
    connection.cancelScannerSubscription(qqqq_id())


tick_msgs = []


def run_2(connection):
    def cb(msg):
        tick_msgs.append(msg)
    connection.register(cb, 'TickSize', 'TickPrice')
    connection.reqMktData(qqqq_id(),
                          qqqq_contract(),
                          '100,101,104,106,162,165,221,225,236',
                          False)
    short_sleep()
    connection.cancelMktData(qqqq_id())


def run_3(connection):
    contract = qqqq_contract()
    connection.reqMktDepth(qqqq_id(), qqqq_contract(), 10)
    short_sleep()
    connection.cancelMktDepth(qqqq_id())


def run_4(connection):
    connection.reqAllOpenOrders()
    connection.reqAutoOpenOrders(True)
    connection.reqOpenOrders()
    connection.reqExecutions(exec_filter())


def run_5(connection):
    connection.reqNewsBulletins(True)
    short_sleep()
    connection.cancelNewsBulletins()


def run_6(connection):
    try:
        askprice = [m.price for m in tick_msgs
                    if getattr(m, 'price', None) and m.field==2][0]
    except (IndexError, ):
        askprice = 100.0
    order = qqqq_order(askprice)
    connection.placeOrder(id=qqqq_order_id(),
                          contract=qqqq_contract(),
                          order=order)
    #connection.exerciseOptions()
    contract = qqqq_contract()
    connection.reqContractDetails(contract)


def run_7(connection):
    endtime = strftime('%Y%m%d %H:%M:%S')
    connection.reqHistoricalData(
            tickerId=qqqq_id(),
            contract=qqqq_contract(),
            endDateTime=endtime,
            durationStr='2 D',
            barSizeSetting='30 mins',
            whatToShow='TRADES',
            useRTH=0,
            formatDate=1)
    short_sleep()
    connection.cancelHistoricalData(qqqq_id())


def __run_8(connection):
    c = Contract()
    c.m_exchange = 'IDEALPRO'
    c.m_symbol = 'MO'
    c.m_localSymbol = 'MO1C'
    c.m_secType = 'BAG'
    c.m_expiry = '200806'
    leg1 = ComboLeg()
    leg1.m_conId = 123
    leg1.m_ratio = 1
    leg1.m_exchange = 'ONE'
    leg1.m_action = 'SELL'
    leg2 = ComboLeg()
    leg2.m_conId = 125
    leg2.m_ratio = 100
    leg2.m_exchange = 'NYSE'
    leg2.m_action = 'BUY'
    c.m_comboLegs = [leg1, leg2]
    connection.reqMktData(1,
                          c,
                          '100,101,104,106,162,165,221,225,236',
                          False)


##
# Generates tick option computation messages
def run_8(connection):
    def cb(*a, **b):
        print '!!', a, b

    connection.register(cb, 'ExecDetails')
    filtr = exec_filter()
    connection.reqExecutions(filtr)

    c = Contract()
    c.m_symbol = 'GOOG'
    c.m_secType = 'OPT'
    c.m_exchange = 'SMART'
    c.m_right = 'CALL'
    c.m_strike = 360.0
    c.m_expiry = '200806'
    connection.reqMktData(2, c, '', False)
    snooze = 10
    #print 'Waiting %s seconds for %s exec details' % (snooze, filtr.m_symbol)
    sleep(snooze)


def run_9(connection):
    connection.reqRealTimeBars(qqqq_id(), qqqq_contract(),
                               5, 'TRADES', 0)
    short_sleep()


def run_last(connection):
    short_sleep()
    connection.eDisconnect()


unseen_hints = {
    'OpenOrder':'only works with existing order(s) before connecting',
    'RealtimeBar':'only works during trading hours',
    'ReceiveFA':'does not work with demo account',
    'UpdateNewsBulletin':'news bulletins may not be available',
    'ConnectionClosed':'may work if TWS is closed during script',
    }


def main():
    con = ibConnection(host, port, client_id)
    con.registerAll(watcher())
    con.connect()
    short_sleep()

    calls = [v for k, v in globals().items() if k.startswith('run_')]
    for call in sorted(calls):
        call(con)

    type_count = len(rec_msgs)
    seen_items = rec_msgs.items()
    seen = [(k, v) for k, v in seen_items if v]
    unseen = [(k, v) for k, v in seen_items if not v]
    errors = [v for k, v in seen_items if k.typeName=='Error']

    print
    if errors:
        errors = errors[0]
        print 'Errors (%s):' % len(errors)
        for err in errors:
            print '%8s: %s' % (err.errorCode, err.errorMsg)
        print
    if seen:
        print 'Seen Message Types (count):'
        for cls, seq in sorted(seen):
            print '    %s (%s)' % (cls.__name__, len(seq), )
    else:
        print 'Total failure; no messages received.'

    print
    if unseen:
        print 'Unseen Message Types (help):'
        for cls, zero in sorted(unseen):
            name = cls.__name__
            help = unseen_hints.get(name, '')
            print '    %s%s' % (name, ' (%s)' % help if help else '', )
    else:
        print 'All Message types received.'

    print
    print 'Summary:'
    args = (type_count, len(seen), len(unseen),
            100*len(seen)/float(type_count))
    print '   total:%s  seen:%s  unseen:%s  coverage:%2.2f%%' % args


if __name__ == '__main__':
    main()
