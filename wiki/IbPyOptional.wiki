#summary How to use the optional interface provided by IbPy.
#labels Featured

= Synopsis =

{{{
from ib.opt import ibConnection, message

def my_account_handler(msg):
    ... do something with account msg ...

def my_tick_handler(msg):
    ... do something with market data msg ...

connection = ibConnection()
connection.register(my_account_handler, 'UpdateAccountValue')
connection.register(my_tick_handler, 'TickSize', 'TickPrice')
connection.connect()
connection.reqAccountUpdates(...)
}}}


= Details =

!IbPy provides an optional interface that does not require
subclassing.  This interface lives in the {{{ib.opt}}} package, and
provides several conveniences for your use.

To interoperate with this package, first define your handlers.  Each
handler must take a single parameter, a Message instance.  Instances
of Message have attributes and values set by the connection object
before they're passed to your handler.

After your handlers are defined, you associate them with the
connection object via the {{{register}}} method.  You pass your
handler as the first parameter, and you indicate what message types to
send it with parameters that follow it.  Message types can be strings,
or better, Message classes.  Both forms are shown here:

  {{{
  connection.register(my_account_handler, 'UpdateAccountValue')
  connection.register(my_tick_handler, message.TickPrice, message.TickSize)
  }}}

You can break the association between your handlers and messages with
the {{{unregister}}} method, like so:

  {{{
  connection.unregister(my_tick_handler, message.TickSize)
  }}}

In the above example, {{{my_tick_handler}}} will still be called with
TickPrice messages.

Connection objects also allow you to associate a handler with *all*
messages generated.  The call looks like this:

  {{{
  connection.registerAll(my_generic_handler)
  }}}

And of course, there's an {{{unregisterAll}}} method as well:

  {{{
  connection.unregisterAll(my_generic_handler)
  }}}


== Attributes ==

The Connection class exposes the attributes of its connection, so you
can write:

  {{{
  connection.reqIds()
  }}}

== Logging ==

The Connection class provides a basic logging facility (via the Python
logging module).  To activate it, call it like this:

  {{{
  connection.enableLogging()
  }}}

To deactivate logging, call the same method with False as the first
parameter:

   {{{
   connection.enableLogging(False)
   }}}


== Message Objects ==

Your handlers are passed a single parameter, an instance of the
Message class (or one of its subclasses).  These instances will have
attributes that match the parameter names from the underlying method
call.  For example, when you're passed a Message instance generated
from a TickSize call, the object might look like this:

  {{{
  msg.tickerId = 4
  msg.field = 3
  msg.size = 100
  }}}

== Threading ==

!IbPy plays nice with three different thread models: native Python
threads, Qt3 and Qt4 threads.  If the package detects a prior import
of Qt3 or Qt4, it will select the appropriate thread class for the
(internal) EReader instance.  The only requirement is that you *must*
import Qt3 or Qt4 first.

  {{{
  from PyQt4 import QtGui
  from ib.opt import ibConnection  ## this works
  }}}

  {{{
  from ib.opt import ibConnection ## wrong thread model selected!
  from qt import *
  }}}

