#!/usr/bin/env python
# -*- coding: utf-8 -*-

##
# This script attempts to determine how much of the TWS API is
# available from IbPy.
#
# It's not meant as an example of correct use of the package, nor is
# it an example of correct use of a programming language.
#
##
from functools import partial
from optparse import OptionParser
from time import sleep, strftime

from ib.ext.ComboLeg import ComboLeg
from ib.ext.Contract import Contract
from ib.ext.ExecutionFilter import ExecutionFilter
from ib.ext.Order import Order
from ib.ext.ScannerSubscription import ScannerSubscription
from ib.opt import ibConnection, message


rec_msgs = {}
unrec_msgs = {}
order_ids = [0]
short_sleep = partial(sleep, 1)
long_sleep = partial(sleep, 10)
tick_msgs = []
gen_tick_keys = '100,101,104,106,162,165,221,225,236'
unseen_hints = {
    'OpenOrder':'only works with existing order(s) before connecting',
    'RealtimeBar':'only works during trading hours',
    'ReceiveFA':'does not work with edemo account',
    'UpdateNewsBulletin':'news bulletins may not be available',
    'ConnectionClosed':'may work if TWS is closed during script',
    }


def next_order_id():
    return order_ids[-1]


def save_order_id(msg):
    order_ids.append(msg.orderId)


def save_tick(msg):
    tick_msgs.append(msg)


def qqqq_id():
    return 0


def qqqq_contract():
    qqqq = Contract()
    qqqq.m_symbol = 'QQQQ'
    qqqq.m_secType = 'STK'
    qqqq.m_exchange = 'SMART'
    return qqqq


def qqqq_order(limit_price):
    order = Order()
    order.m_minQty = 100
    order.m_lmtPrice = limit_price
    order.m_orderType = 'MKT'
    order.m_totalQuantity = 100
    order.m_action = 'BUY'
    return order


def exec_filter(client_id):
    contract = qqqq_contract()
    filt = ExecutionFilter()
    filt.m_clientId = client_id
    filt.m_symbol = contract.m_symbol
    filt.m_secType = contract.m_secType
    filt.m_exchange = contract.m_exchange
    return filt


def make_msg_counter():
    rec_msgs.update(dict([(c, []) for c in message.registry.values()]))
    def counter(msg):
        cls = msg.__class__
        try:
            rec_msgs[cls].append(msg)
        except (KeyError, ):
            unrec_msgs.setdefault(cls, []).append(msg)
    return counter


def test_000(connection, options):
    connection.setServerLogLevel(5)
    connection.reqCurrentTime()
    connection.reqAccountUpdates(1, 'DF16165')
    connection.reqManagedAccts()
    connection.requestFA(connection.GROUPS)
    connection.replaceFA(connection.GROUPS, '')
    connection.reqIds(10)


def test_001(connection, options):
    subscript = ScannerSubscription()
    subscript.numberOfRows(3)
    subscript.locationCode('STK.NYSE')
    connection.reqScannerSubscription(qqqq_id(), subscript)
    connection.reqScannerParameters()
    short_sleep()
    connection.cancelScannerSubscription(qqqq_id())


def test_002(connection, options):
    connection.reqMktData(qqqq_id(), qqqq_contract(), gen_tick_keys, False)
    short_sleep()
    connection.cancelMktData(qqqq_id())


def test_003(connection, options):
    contract = qqqq_contract()
    connection.reqMktDepth(qqqq_id(), qqqq_contract(), 10)
    short_sleep()
    connection.cancelMktDepth(qqqq_id())


def test_004(connection, options):
    connection.reqAllOpenOrders()
    connection.reqAutoOpenOrders(True)
    connection.reqOpenOrders()
    connection.reqExecutions(exec_filter(options.clientid))


def test_005(connection, options):
    connection.reqNewsBulletins(True)
    short_sleep()
    connection.cancelNewsBulletins()


def test_006(connection, options):
    try:
        askprice = [m.price for m in tick_msgs
                    if getattr(m, 'price', None) and m.field==2][0]
    except (IndexError, ):
        askprice = 100.0
    order = qqqq_order(askprice)
    if options.demo:
        connection.placeOrder(id=next_order_id(),
                              contract=qqqq_contract(),
                              order=order)
    #connection.exerciseOptions()
    contract = qqqq_contract()
    connection.reqContractDetails(contract)


def test_007(connection, options):
    endtime = strftime('%Y%m%d %H:%M:%S')
    connection.reqHistoricalData(
            tickerId=qqqq_id(),
            contract=qqqq_contract(),
            endDateTime=endtime,
            durationStr='2 D',
            barSizeSetting='30 mins',
            whatToShow='TRADES',
            useRTH=0,
            formatDate=1)
    short_sleep()
    connection.cancelHistoricalData(qqqq_id())


def test_008a(connection, options):
    c = Contract()
    c.m_exchange = 'IDEALPRO'
    c.m_symbol = 'MO'
    c.m_localSymbol = 'MO1C'
    c.m_secType = 'BAG'
    c.m_expiry = '200806'
    leg1 = ComboLeg()
    leg1.m_conId = 123
    leg1.m_ratio = 1
    leg1.m_exchange = 'ONE'
    leg1.m_action = 'SELL'
    leg2 = ComboLeg()
    leg2.m_conId = 125
    leg2.m_ratio = 100
    leg2.m_exchange = 'NYSE'
    leg2.m_action = 'BUY'
    c.m_comboLegs = [leg1, leg2]
    connection.reqMktData(1, c, gen_tick_keys, False)


def test_008b(connection, options):
    def cb(*a, **b):
        print '!!', a, b
    connection.register(cb, 'ExecDetails')
    filtr = exec_filter(options.clientid)
    connection.reqExecutions(filtr)
    c = Contract()
    c.m_symbol = 'GOOG'
    c.m_secType = 'OPT'
    c.m_exchange = 'SMART'
    c.m_right = 'CALL'
    c.m_strike = 360.0
    c.m_expiry = '200806'
    connection.reqMktData(2, c, '', False)
    long_sleep()


def test_009(connection, options):
    connection.reqRealTimeBars(qqqq_id(), qqqq_contract(), 5, 'TRADES', 0)
    short_sleep()


def test_999(connection, options):
    short_sleep()
    connection.eDisconnect()


def main(options):
    con = ibConnection(options.host, options.port, options.clientid)
    con.registerAll(make_msg_counter())
    con.register(save_order_id, 'NextValidId')
    con.register(save_tick, 'TickSize', 'TickPrice')
    con.connect()
    short_sleep()

    calls = [v for k, v in globals().items() if k.startswith('test_')]
    for call in sorted(calls):
        call(con, options)

    type_count = len(rec_msgs)
    seen_items = rec_msgs.items()
    seen = [(k, v) for k, v in seen_items if v]
    unseen = [(k, v) for k, v in seen_items if not v]
    errors = [v for k, v in seen_items if k.typeName=='Error']

    if errors and options.errors:
        errors = errors[0]
        print '\nErrors (%s):' % len(errors)
        for err in errors:
            print '%8s: %s' % (err.errorCode, err.errorMsg)
    if seen:
        print '\nSeen Message Types (count):'
        for cls, seq in sorted(seen):
            print '    %s (%s)' % (cls.__name__, len(seq), )
    else:
        print '\nTotal failure; no messages received.'

    if unseen:
        print '\nUnseen Message Types (help):'
        for cls, zero in sorted(unseen):
            name = cls.__name__
            help = unseen_hints.get(name, '')
            print '    %s%s' % (name, ' (%s)' % help if help else '', )
    else:
        print '\nAll Message types received.'

    print '\nSummary:'
    args = (type_count, len(seen), len(unseen), 100*len(seen)/float(type_count))
    print '   total:%s  seen:%s  unseen:%s  coverage:%2.2f%%' % args


def get_options():
    version = '%prog 0.1'
    parser = OptionParser(version=version)
    parser.add_option('-e', '--errors', dest='errors',
                      help='Report errors in summary.', action="store_true")
    parser.add_option('', '--host', dest='host',
                      help='Name or address of host for remote connection', default='localhost')
    parser.add_option('-p', '--port', dest='port',
                      help='Port number for remote connection', default=7496, type='int')
    parser.add_option('-c', '--client', dest='clientid',
                      help='Client id for remote connection', default=0, type='int')
    parser.add_option('-d', '--demo', dest='demo',
                      help='Server using demo account, safe for placing orders.', action='store_true')
    opts, args = parser.parse_args()
    return opts


if __name__ == '__main__':
    main(get_options())
