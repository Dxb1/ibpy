#!/usr/bin/env python
""" Ib.Message -> Interactive Brokers socket readers

    These types provide the logic of reading encoded TWS data and turning that 
    data into EventDetail objects.  The types inherit the dispatch method, which
    they use to send the EventDetail objects to registered listeners.
"""
import Ib.Type


class SocketReader(object):
    """ SocketReader()

        Subtypes encapsulate the logic of reading values from a socket object
        encoded by the TWS application.  After instances read data, they 
        generate EventDetail objects and send them to registered listeners via the 
        dispatch method.
    """
    def __init__(self):
        self.listeners = []

    def dispatch(self, **kwds):
        """ dispatch(**kwds) -> send a new EventDetail instance to listeners

            Right or wrong, this method swallows any exception generated by the
            listener.
        """
        for listener in self.listeners:
            try:
                listener(self.EventDetail(**kwds))
            except (Exception, ), ex:
                print ex


class SocketDetail(object):
    """ SocketDetail(**kwds)

        Subtypes must respecify __slots__ for instances to have attributes.
        The keywords specified in the constructor must be present in the 
        __slots__ tuple.
    """
    __slots__ = ()

    def __init__(self, **kwds):
        for name, value in kwds.items():
            setattr(self, name, value)


class Account(SocketReader):
    """ Account() -> parent type for account-related readers

        Using a parent class enables the client to specify a single listener 
        for multiple but related readers.
    """
    class EventDetail(SocketDetail):
        __slots__ = ('key', 'value', 'currency', )


class AccountValue(Account):
    """ AccountValue() -> reads account value messages

        Generated EventDetail instance:

        event.key - name of the account update field
        event.value - value of the update
        event.currency - currency type
    """
    def read(self, read_int, read_float, read_str):
        """ read(...) -> read an account value message

        """
        throwaway_version = read_int()
        key = read_str()
        value = read_str()
        currency = read_str()

        ## suppress empty strings but not 0.0 or 0
        ## this odd behavior is new, and needs to be checked
        ## against current ib client sources

        if value == '':
            return

        ## otherwise just dispatch the event normally
        self.dispatch(key=key,
                      value=value,
                      currency=currency)


class AccountTime(Account):
    """ AccountTime() -> reads account time stamp messages

        Generated message instance:

        event.key - 'TimeStamp'
        event.value - time the broker updated the account
        event.currency - ""
    """
    def read(self, read_int, read_float, read_str):
        """ read(...) -> read an account update time message

        """
        throwaway_version = read_int()
        time_stamp = read_str()
        self.dispatch(key='TimeStamp',
                      value=time_stamp,
                      currency='')


class ContractDetails(SocketReader):
    """ ContractDetails() -> reads contract detail messages

        Generated message instance:

        event.details - full description of a contract
    """
    class EventDetail(SocketDetail):
        __slots__ = ('details', )


    def read(self, read_int, read_float, read_str):
        """ read(...) -> read a contract details message

        """
        details = Ib.Type.ContractDetails()

        throwaway_version = read_int()
        details.summary.symbol = read_str()
        details.summary.sec_type = read_str()

        details.summary.expiry = read_str()
        details.summary.strike = read_float()
        details.summary.right = read_str()

        details.summary.exchange = read_str()
        details.summary.currency = read_str()
        details.summary.local_symbol = read_str()

        details.market_name = read_str()
        details.trading_class = read_str()
        details.con_id = read_int()

        details.min_tick = read_float()
        details.multiplier = read_str()
        details.order_types = read_str()

        details.valid_exchanges = read_str()
        self.dispatch(details=details)


class Error(SocketReader):
    """ Error() -> reads error messages

        Generated message instance:

        event.error_id - order id or ticker id that generated the error
        event.error_code - error codes are documented by IB
        event.error_msg - textual description of the error, documented by IB
    """
    class EventDetail(SocketDetail):
        __slots__ = ('error_id', 'error_code', 'error_msg', )


    def read(self, read_int, read_float, read_str):
        """ read(...) -> read an error message

        """
        throwaway_version = read_int()

        error_id = read_int()
        error_code = read_int()
        error_msg = read_str()

        self.dispatch(error_id=error_id, 
                      error_code=error_code, 
                      error_msg=error_msg)


class ExecutionDetails(SocketReader):
    """ ExecutionDetails() -> reads execution detail messages

        Generated message instance:

        event.order_id - order id specified in the call to place order
        event.contract - description of the executed contract 
        event.details - addition order execution details
    """
    class EventDetail(SocketDetail):
        __slots__ = ('order_id', 'contract', 'details', )

    def read(self, read_int, read_float, read_str):
        """ read(...) -> read an execution details message

        """
        contract = Ib.Type.Contract()
        details = Ib.Type.ExecutionDetails()

        throwaway_version = read_int()
        order_id = read_int()
        contract.symbol = read_str()

        contract.sec_type = read_str()
        contract.expiry = read_str()
        contract.strike = read_float()

        contract.right = read_str()
        contract.exchange = read_str()
        contract.currency = read_str()

        contract.local_symbol = read_str()
        details.order_id = order_id
        details.exec_id = read_str()

        details.time = read_str()
        details.acct_number = read_str()
        details.exchange = read_str()

        details.side = read_str()
        details.shares = read_int()
        details.price = read_float()

        details.perm_id = read_int()
        details.client_id = read_int()
        self.dispatch(order_id=order_id,
                      contract=contract,
                      details=details)


class ManagedAccounts(SocketReader):
    """ ManagedAccounts() -> reads a list of managed account ids

    """
    class EventDetail(SocketDetail):
        __slots__ = ('accounts', )

    def read(self, read_int, read_float, read_str):
        """ read(...) -> read a managed accounts message

        """
        throwaway_version = read_int()
        accounts = read_str()
        self.dispatch(accounts=accounts)


class MarketDepth(SocketReader):
    """ MarketDepth() -> reads market depth messages

        Generated message instance:

        event.ticker_id - ticker id specified the call to request_market_depth
        event.position - specifies the row id of the order
        event.operation - identifies how this message should be applied to the
                          market depth.  Valid values:
                          0 = insert
                          1 = update
                          2 = delete
        event.side - side of the book to which this order belongs. Valid values:
                     0 = ask
                     1 = bid
        event.price - order price
        event.size - order size
    """
    class EventDetail(SocketDetail):
        __slots__ = ('ticker_id', 'position', 'operation', 
                     'side', 'price', 'size', )


    def read(self, read_int, read_float, read_str):
        """ read(...) -> read a market depth message

        """
        throwaway_version = read_int()

        ticker_id = read_int()
        position = read_int()
        operation = read_int()

        side = read_int()
        price = read_float()
        size = read_int()

        self.dispatch(ticker_id=ticker_id,
                      position=position,
                      operation=operation,
                      side=side,
                      price=price,
                      size=size)


class MarketDepthLevel2(SocketReader):
    """ MarketDepthLevel2Reader() -> reads level 2 market depth messages

        Generated message instance:

        event.ticker_id - ticker id specified the call to request_market_depth
        event.position - specifies the row id of the order
        event.market_maker - specifies the exchange hosting this order
        event.operation - identifies how this message should be applied to the
                          market depth.  Valid values:
                          0 = insert
                          1 = update
                          2 = delete
        event.side - side of the book to which this order belongs. Valid values:
                     0 = ask
                     1 = bid
        event.price - order price
        event.size - order size
    """
    class EventDetail(SocketDetail):
        __slots__ = ('ticker_id', 'position', 'market_maker', 'operation', 
                     'side', 'price', 'size', )

    def read(self, read_int, read_float, read_str):
        """ read(...) -> read a market depth level 2 message

        """
        throwaway_version = read_int()

        ticker_id = read_int()
        position = read_int()
        market_maker = read_str()

        operation = read_int()
        side = read_int()
        price = read_float()

        size = read_int()
        self.dispatch(ticker_id=ticker_id,
                      position=position,
                      market_maker=market_maker,
                      operation=operation, 
                      side=side,
                      price=price,
                      size=size)


class NextId(SocketReader):
    """ NextId() -> reads next valid id messages

        Generated message instance:

        event.next_valid_id - first order id acceptable to the broker
    """
    class EventDetail(SocketDetail):
        __slots__ = ('next_valid_id', )

    def read(self, read_int, read_float, read_str):
        """ read(...) -> read a next order id message

        """
        throwaway_version = read_int()
        next_valid_id = read_int()
        self.dispatch(next_valid_id=next_valid_id)


class OpenOrder(SocketReader):
    """ OpenOrder() -> reads open order messages

        Generated message instance:

        event.order_id - the order id assigned by the broker
        event.contract - describes the contract
        event.order - details of the open order
    """
    class EventDetail(SocketDetail):
        __slots__ = ('order_id', 'contract', 'order', )

    def read(self, read_int, read_float, read_str):
        """ read(...) -> read an open order message

        """
        contract = Ib.Type.Contract()
        order = Ib.Type.Order()

        throwaway_version = read_int()
        order_id = read_int()
        contract.symbol = read_str()

        contract.sec_type = read_str()
        contract.expiry = read_str()
        contract.strike = read_float()

        contract.right = read_str()
        contract.exchange = read_str()
        contract.currency = read_str()

        contract.local_symbol = read_str()
        order.action = read_str()
        order.quantity = read_int()

        order.order_type = read_str()
        order.limit_price = read_float()
        order.aux_price = read_float()

        order.tif = read_str()
        order.oca_group = read_str()
        order.account = read_str()

        order.open_close = read_str()
        order.origin = read_int()
        order.order_ref = read_str()

        order.client_id = read_int()
        self.dispatch(order_id=order_id, 
                      contract=contract, 
                      order=order)


class OrderStatus(SocketReader):
    """ OrderStatus() -> reads order status messages

        Generated message instance:

        event.order_id - order id specified previously 
        event.message - order status
        event.filled - number of shares executed
        event.remaining - number of shares still outstanding
        event.avg_fill_price - average price of executed shares 
        event.perm_id - permanent id maintained by the broker
        event.parent_id - parent id for bracket or auto trailing stop orders
        event.last_fill_price - price of the last shares executed
    """
    class EventDetail(SocketDetail):
        __slots__ = ('order_id', 'message', 'filled', 'remaining',  'perm_id',
                     'parent_id', 'last_fill_price', 'avg_fill_price', 
                     'client_id')

    def read(self, read_int, read_float, read_str):
        """ read(...) -> read an order status message

        """
        throwaway_version = read_int()

        order_id = read_int()
        message = read_str()
        filled = read_int()

        remaining = read_int()
        avg_fill_price = read_float()
        perm_id = read_int()

        parent_id = read_int()
        last_fill_price = read_float()
        client_id = read_int()

        self.dispatch(order_id=order_id,
                      message=message,
                      filled=filled,
                      remaining=remaining,
                      avg_fill_price=avg_fill_price,
                      perm_id=perm_id,
                      parent_id=parent_id,
                      last_fill_price=last_fill_price,
                      client_id=client_id)


class Portfolio(SocketReader):
    """ Portfolio() -> reads portfolio update messages 

        Generated message instance:

        event.contract - description of the contract
        event.position - indicates the position on the contract
        event.market_price - unit price of the instrument
        event.market_value - total market value of the instrument
    """
    class EventDetail(SocketDetail):
        __slots__ = ('contract', 'position', 'market_price', 'market_value', 
                     'average_cost', 'unrealized_pnl', 'realized_pnl')

    def read(self, read_int, read_float, read_str):
        """ read(...) -> read a portfolio update message

        """
        contract = Ib.Type.Contract()

        throwaway_version = read_int()
        contract.symbol = read_str()
        contract.sec_type = read_str()

        contract.expiry = read_str()
        contract.strike = read_float()
        contract.right = read_str()

        contract.currency = read_str()
        contract.local_symbol = read_str()
        position = read_int()

        market_price = read_float()
        market_value = read_float()

        average_cost = read_float()
        unrealized_pnl = read_float()
        realized_pnl = read_float()

        self.dispatch(contract=contract,
                      position=position,
                      market_price=market_price,
                      market_value=market_value,
                      average_cost=average_cost,
                      unrealized_pnl=unrealized_pnl,
                      realized_pnl=realized_pnl)


class ReaderStart(SocketReader):
    """ ReaderStart() -> pseudo message for reader start notification

        Instances do not have a 'read' method, but messages are sent with with
        the 'send' method just the same.  The message layout is:

        event - unadorned
    """
    class EventDetail(SocketDetail):
        __slots__ = ()


class ReaderStop(SocketReader):
    """ ReaderStart() -> pseudo message for reader stop notification

        Instances do not have a 'read' method, but messages are sent with with
        the 'send' method just the same.  The message layout is:

        event.exception - string of the exception that stopped the reader
    """
    class EventDetail(SocketDetail):
        __slots__ = ('exception', )


class Ticker(SocketReader):
    """ Ticker() -> parent type for ticker-related readers

        Using a parent class enables the client to specify a single listener 
        for multiple but related readers.
    """
    class EventDetail(SocketDetail):
        """ EventDetail type tweaked for ticker updates

            Ticker updates are the most frequent message sent by TWS.  This type
            is slightly faster than the SocketDetail base class.
        """
        __slots__ = ('ticker_id', 'field', 'value', )

        def __init__(self, ticker_id, field, value):
            self.ticker_id, self.field, self.value = ticker_id, field, value


class TickerPrice(Ticker):
    """ TickerPrice() -> reads ticker price messages

        Generated message instance:

        event.ticker_id - ticker id previously specified
        event.field - type of price (ask, bid, last, etc)
        event.value - price of indicated field 
    """
    def read(self, read_int, read_float, read_str):
        """ read(...) -> read a ticker price message

        """
        throwaway_version = read_int()
        ticker_id = read_int()
        price_type = read_int()
        price = read_float()

        self.dispatch(ticker_id=ticker_id,
                      field=price_type,
                      value=price)


class TickerSize(Ticker):
    """ TickerSize() -> reads ticker size messages

        Generated message instance:

        event.ticker_id - ticker id previously specified
        event.field - type of size (ask, bid, last, etc)
        event.value - size of indicated field
    """
    def read(self, read_int, read_float, read_str):
        """ read(...) -> read a ticker size message

        """
        throwaway_version = read_int()
        ticker_id = read_int()
        size_type = read_int()
        size = read_int()

        self.dispatch(ticker_id=ticker_id,
                      field=size_type,
                      value=size)


class NewsBulletin(SocketReader):
    """ NewsBulletin() -> reads news bulletin messages

    """
    class EventDetail(SocketDetail):
        __slots__ = ('news_id', 'news_type', 'news_message', 'news_exchange')

    def read(self, read_int, read_float, read_str):
        """ read(...) -> read a news bulletin message

        """
        throwaway_version = read_int()
        news_id = read_int()
        news_type = read_int()
        news_message = read_str()
        news_exchange = read_str()

        self.dispatch(news_id=news_id,
                      news_type=news_type,
                      news_message=news_message,
                      news_exchange=news_exchange)

